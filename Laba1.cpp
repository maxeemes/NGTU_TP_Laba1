#include <iostream>
#include <stdlib.h>
#include <string>
#include <Windows.h>

//Задача 8.
//По кругу расположено N монет гербами вверх и M монет гербами вниз.Обходя круг
//по ходу часовой стрелки, переворачивает каждую S - тую монету.В первый раз 
//счет начинается с герба.В каком порядке надо расставить монеты, 
//чтобы после K ходов стало L монет, лежащих гербами вверх.

//TODO: Сделать структуру для хранения информации о наборе монет

using namespace std;



int main()
{
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
	int M = 5; //монет гербами вниз
	int N = 4; //монет гербами вверх
	int S = 3; //шаг
	int K = 2; //количество шагов
	int L = 5; //монет гербами вверх после выполнения
	int p = 0; //количество монет будет перевернуто

	int SumNM = N + M;				//количество монет
	int *A = new int[SumNM] {0};	//монеты которые перевернутся
	
	for (int i = 0, pos = 0; i < K; i++)	//рассчитываем какие монеты будут перевернуты
	{
		A[pos] = 1 - A[pos];
		pos += S;
		if (pos >= SumNM)	//переход в начало массива при достижении конца
		{
			pos -= SumNM;
		}
	}

	for (int i = 0; i < SumNM; i++)			//рассчитываем какое количество монет будет перевернуто
	{
		p += A[i];
		cout << A[i];	//последовательно выводим монеты которые будут перевернуты
	}
	//-------------------------------------
	//Определение типа преобразования
	if (L >= N)		//1й тип преобразования
	{
		int O = L - N;	//переворачиваемые монеты гербами вниз
		int Q = p - O;	//переворачиваемые монеты, где 1 половина гербами вниз, а другая вверх
		int v = Q / 2;	//половина переворчиваемых монет
		if (Q >= 0 && ((v * 2) == Q) && v <= N && ((v + O) <= M))	//проверка возможности преобразования
		{
			int v0 = v, v1 = v;	//переворачиваемые монеты 
								//v0 - гербами вниз; v1 - гербами вверх
			if (A[0] == 0 && N > v1)
			{
				int *coins = new int[SumNM] {0};	//массив с положениями монет
													//0 - гербами вниз; 1 - гербами вверх
				coins[0] = 1;
				N--;
				//------------------------------------------
				//преобразование
				for (int i = 1; i < SumNM; i++)
				{
					if (A[i] == 1)
					{
						if (O > 0)
						{
							//coins[i] = 0;
							O--;
							M--;
						}
						else if (v0 > 0)
						{
							//coins[i] = 0;
							v0--;
							M--;
						}
						else if (v1 > 0)
						{
							coins[i] = 1;
							v1--;
							N--;
						}
						else
						{
							//ошибка преобразования A[i] == 1
						}
					}
					else if (A[i] == 0)
					{
						if ((M - (O + v0)) > 0)
						{
							//coins[i] = 0;
							M--;
						}
						else if ((N - v1) > 0)
						{
							coins[i] = 1;
							N--;
						}
						else
						{
							//ошибка преобразования A[i] == 0
						}
					}
					else
					{
						//ошибка некорректное значение в массиве A
					}
				}
				//------------------------------------------
			}
			else if (A[0] == 1 && v1 > 0) //среди переворачиваемых монет должна быть по крайней мере одна, которую необходимо положить гербом вверх
			{
				int *coins = new int[SumNM] {0};	//массив с положениями монет
													//0 - гербами вниз; 1 - гербами вверх
				coins[0] = 1;
				v1--;
				N--;
				//------------------------------------------
				//преобразование
				for (int i = 1; i < SumNM; i++)
				{
					if (A[i] == 1)
					{
						if (O > 0)
						{
							//coins[i] = 0;
							O--;
							M--;
						}
						else if (v0 > 0)
						{
							//coins[i] = 0;
							v0--;
							M--;
						}
						else if (v1 > 0)
						{
							coins[i] = 1;
							v1--;
							N--;
						}
						else
						{
							//ошибка преобразования A[i] == 1
						}
					}
					else if (A[i] == 0)
					{
						if ((M - (O + v0)) > 0)
						{
							//coins[i] = 0;
							M--;
						}
						else if ((N - v1) > 0)
						{
							coins[i] = 1;
							N--;
						}
						else
						{
							//ошибка преобразования A[i] == 0
						}
					}
					else
					{
						//ошибка некорректное значение в массиве A
					}
				}
				//------------------------------------------
			}
			else
			{
				cout << "Ошибка!!! Преобразование невозможно!!!";
			}
		}
		else
		{
			cout << "Ошибка!!! Преобразование невозможно!!!";
		}
	}
	else if (L < N)	//2й тип преобразования
	{
		int O = N - L;	//переворачиваемые монеты гербами вверх
		int Q = p - O;	//переворачиваемые монеты, где 1 половина гербом вниз, а другая вверх
		int v = Q / 2;	//половина переворчиваемых монет
		if (Q >= 0 && ((v * 2) == Q) && v <= M && ((v + O) <= N))	//проверка возможности преобразования
		{
			int v0 = v, v1 = v;	//переворачиваемые монеты 
								//v0 - гербами вниз; v1 - гербами вверх
			if (A[0] == 0 && N > v1)
			{
				int *coins = new int[SumNM] {0};	//массив с положениями монет
													//0 - гербами вниз; 1 - гербами вверх
				coins[0] = 1;
				N--;
				//------------------------------------------
				//преобразование
				for (int i = 1; i < SumNM; i++)
				{
					if (A[i] == 1)
					{
						if (O > 0)
						{
							coins[i] = 1;
							O--;
							N--;
						}
						else if (v0 > 0)
						{
							//coins[i] = 0;
							v0--;
							M--;
						}
						else if (v1 > 0)
						{
							coins[i] = 1;
							v1--;
							N--;
						}
						else
						{
							//ошибка преобразования A[i] == 1
						}
					}
					else if (A[i] == 0)
					{
						if ((N - (O + v1)) > 0)
						{
							coins[i] = 1;
							N--;
						}
						else if ((M - v0) > 0)
						{
							//coins[i] = 0;
							M--;
						}
						else
						{
							//ошибка преобразования A[i] == 0
						}
					}
					else
					{
						//ошибка некорректное значение в массиве A
					}
				}
				//------------------------------------------
			}
			else if (A[0] == 1 && (v1 + O) > 0) //среди переворачиваемых монет должна быть по крайней мере одна, которую необходимо положить гербом вверх
			{
				int *coins = new int[SumNM] {0};	//массив с положениями монет
													//0 - гербами вниз; 1 - гербами вверх
				coins[0] = 1;
				v1--;
				N--;
				//------------------------------------------
				//преобразование
				for (int i = 1; i < SumNM; i++)
				{
					if (A[i] == 1)
					{
						if (O > 0)
						{
							//coins[i] = 0;
							O--;
							M--;
						}
						else if (v0 > 0)
						{
							//coins[i] = 0;
							v0--;
							M--;
						}
						else if (v1 > 0)
						{
							coins[i] = 1;
							v1--;
							N--;
						}
						else
						{
							//ошибка преобразования A[i] == 1
						}
					}
					else if (A[i] == 0)
					{
						if ((M - (O + v0)) > 0)
						{
							coins[i] = 0;
							M--;
						}
						else if ((N - v1) > 0)
						{
							coins[i] = 1;
							N--;
						}
						else
						{
							//ошибка преобразования A[i] == 0
						}
					}
					else
					{
						//ошибка некорректное значение в массиве A
					}
				}
				//------------------------------------------
			}
			else
			{
				cout << "Ошибка!!! Преобразование невозможно!!!";
			}
		}
		else
		{
			cout << "Ошибка!!! Преобразование невозможно!!!";
		}
	}
	else 
	{
		cout << "ОШИБКА ВЫПОЛНЕНИЯ!!!";
	}

	return 0;
}
//----------------------------------------------------------------------------------------
int Processing(int *coins, int *A, int Len, int N, int M, int O, int v, int type) //преобразование, значения type: 0-3
{
	int v0 = v, v1 = v;
	bool IsOInN = type >= 2;
	coins[0] = 1;
	N--;
	if (type % 2 > 0)
	{
		v1--;
	}

	for (int i = 1; i < Len; i++)
	{
		if (A[i] == 1)
		{
			if (O > 0)
			{
				coins[i] = 1;
				O--;
				if (IsOInN)
				{
					N--;
				}
				else
				{
					M--;
				}
			}
			else if (v0 > 0)
			{
				//coins[i] = 0;
				v0--;
				M--;
			}
			else if (v1 > 0)
			{
				coins[i] = 1;
				v1--;
				N--;
			}
			else
			{
				//ошибка преобразования A[i] == 1
			}
		}
		else if (A[i] == 0 && IsOInN)
		{
			if ((N - (O + v1)) > 0)
			{
				coins[i] = 1;
				N--;
			}
			else if ((M - v0) > 0)
			{
				//coins[i] = 0;
				M--;
			}
			else
			{
				//ошибка преобразования A[i] == 0
			}
		}
		else if (A[i] == 0 && !IsOInN)
		{
			if ((N - v1) > 0)
			{
				coins[i] = 1;
				N--;
			}
			else if ((M - (O + v0)) > 0)
			{
				//coins[i] = 0;
				M--;
			}
			else
			{
				//ошибка преобразования A[i] == 0
			}
		}
		else
		{
			//ошибка некорректное значение в массиве A
		}
	}
	return 0;
}
//----------------------------------------------------------------------------------------